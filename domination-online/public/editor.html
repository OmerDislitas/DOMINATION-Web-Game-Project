<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DOMINATION – Hex Harita Editörü</title>
  <style>
    :root { --bg:#0b2f33; --panel:#0f3f45; --ink:#e7f6f7; --muted:#8ed0d6; --accent:#ffce54; }
    * { box-sizing: border-box; }
    body { margin:0; background:var(--bg); color:var(--ink); font:14px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    header { display:flex; gap:12px; align-items:center; padding:12px 16px; background:linear-gradient(180deg, #0e3a41, #0c3338); border-bottom:1px solid #0a2a2e; position:sticky; top:0; z-index:2; }
    h1 { font-size:16px; margin:0; letter-spacing:.5px; }
    .wrap { display:grid; grid-template-columns: 320px 1fr; height: calc(100vh - 56px); }
    .panel { background:var(--panel); border-right:1px solid #0a2a2e; padding:14px; overflow:auto; }
    .group { margin-bottom:14px; padding:12px; background:#114a51; border:1px solid #0a2a2e; border-radius:10px; }
    .group h3 { margin:0 0 8px; font-size:13px; color:var(--muted); font-weight:600; }
    label { display:block; margin:8px 0 4px; color:var(--muted); font-size:12px; }
    input[type="number"], select, input[type="text"] { width:100%; padding:8px 10px; border-radius:8px; border:1px solid #0a2a2e; background:#0b3a3f; color:var(--ink); }
    .row { display:flex; gap:8px; align-items:center; }
    .row > * { flex:1; }
    .btn { background:#13565e; border:1px solid #0a2a2e; color:var(--ink); padding:8px 10px; border-radius:10px; cursor:pointer; }
    .btn:hover { background:#14656f; }
    .btn.warn { background:#6a1d1d; }
    .btn.warn:hover { background:#7a2323; }
    .chips { display:flex; flex-wrap:wrap; gap:6px; }
    .chip { padding:6px 8px; background:#0b3a3f; border:1px solid #0a2a2e; border-radius:999px; font-size:12px; cursor:pointer; }
    .chip.active { outline:2px solid var(--accent); }
    textarea { width:100%; min-height:140px; resize:vertical; padding:10px; border-radius:10px; border:1px solid #0a2a2e; background:#0b3a3f; color:var(--ink); }
    canvas { display:block; width:100%; height:100%; background:#0c666c; }
    .hint { font-size:12px; color:#bfe8eb; opacity:.85; }
    .sep { height:1px; background:#0a2a2e; margin:10px 0; }
    .grid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }
  </style>
</head>
<body>
  <header>
    <h1>DOMINATION • Hex Harita Editörü</h1>
    <div class="chips" id="modeChips" style="margin-left:auto;">
      <div class="chip active" data-mode="paint">Boyama</div>
      <div class="chip" data-mode="object">Obje</div>
      <div class="chip" data-mode="erase">Sil</div>
      <div class="chip" data-mode="add">Ekle (cursor)</div>
      <div class="chip" data-mode="manual">Manuel Ekle</div>
    </div>
  </header>
  <div class="wrap">
    <aside class="panel">
      <div class="group">
        <h3>Seçenekler</h3>
        <label>Sahip (owner id)</label>
        <input id="ownerInput" type="number" min="0" value="1" />
        <div class="sep"></div>
        <label>Obje</label>
        <select id="objectSelect">
          <option value="">(yok)</option>
          <option value="house">house</option>
          <option value="castle">castle</option>
          <option value="tower">tower</option>
          <option value="strong_tower">strong_tower</option>
        </select>
        <div class="sep"></div>
        <div class="grid">
          <button class="btn" id="btnZoomIn">Yakınlaş</button>
          <button class="btn" id="btnZoomReset">Sıfırla</button>
          <button class="btn" id="btnZoomOut">Uzaklaş</button>
        </div>
      </div>

      <div class="group">
        <h3>Tile Ekle (manuel)</h3>
        <div class="row">
          <input id="rowInput" type="number" placeholder="row" />
          <input id="colInput" type="number" placeholder="col" />
        </div>
        <button class="btn" id="btnAddTile">Ekle</button>
      </div>

      <div class="group">
        <h3>Seçili Tile</h3>
        <div class="row"><input id="selRow" type="number" placeholder="row" disabled><input id="selCol" type="number" placeholder="col" disabled></div>
        <div class="row"><button class="btn" id="btnAddNeighbors">6 komşu ekle</button><button class="btn warn" id="btnDeleteTile">Tile'ı sil</button></div>
        <p class="hint">İpucu: Boyama modunda sol tık sahipliği değiştirir. Obje modunda sol tık obje atar, sağ tık objeyi kaldırır. Sil modunda sol tık tile'ı kaldırır. Ekle (cursor) modunda sol tık ghost tile konumunda yeni tile ekler.</p>
      </div>

      <div class="group">
        <h3>İçe/Dışa Aktar</h3>
        <div class="row"><button class="btn" id="btnExport">Export</button><button class="btn" id="btnCopy">Kopyala</button></div>
        <textarea id="ioBox" spellcheck="false"></textarea>
        <div class="row"><button class="btn" id="btnImport">Import</button><button class="btn warn" id="btnClear">Tümünü Temizle</button></div>
      </div>
    </aside>

    <main>
      <canvas id="canvas"></canvas>
    </main>
  </div>

<script>
// ==== Basit tek-dosya editörü (oyunun formatıyla birebir uyumlu) ====
// landData: satır başına `row col owner [object]`

// Varsayılan renkler (oyunla uyumlu olacak şekilde örnek)
const OWNER_COLORS = ['#2d2d2d', '#4CAF50', '#14BBC7', '#EE6B19', '#BC1EA7', '#FF8C00', '#1E90FF'];

// Canvas ve çizim ayarları
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let scale = 1; let offsetX = 0; let offsetY = 0; let isPanning = false; let startX=0, startY=0;
const tileSize = 40; // yarıçap
const hexH = Math.sqrt(3) * tileSize;

// UI
const ownerInput = document.getElementById('ownerInput');
const objectSelect = document.getElementById('objectSelect');
const modeChips = document.getElementById('modeChips');
let mode = 'paint';

const rowInput = document.getElementById('rowInput');
const colInput = document.getElementById('colInput');
const ioBox = document.getElementById('ioBox');
const selRow = document.getElementById('selRow');
const selCol = document.getElementById('selCol');

// Veri
let landData = (window.landData && Array.isArray(window.landData)) ? [...window.landData] : [
  '5 3 1', '6 3 1', '7 3 1 tower', '8 3 1', '9 3 1',
  '',
  '4 4 3', '5 4 3 tower', '6 4 1', '7 4 1', '8 4 1', '9 4 1', '10 4 0',
].filter(Boolean);


// Yardımcı: koordinat ↔ piksel (flat-top, odd-q offset)
function hexToPixel(row, col) {
  const parity = col & 1;                  // 0: even, 1: odd  (negatifte de doğru)
  const x = tileSize * 1.5 * col;
  const y = hexH * (row + 0.5 * parity);
  return { x, y };
}
// Dünya (wx, wy) -> en yakın odd-q (row,col) 'snap'
function pixelToHex(wx, wy) {
  const col = Math.round(wx / (1.5 * tileSize));
  const row = Math.round(wy / hexH - 0.5 * (col & 1));
  return { row, col };
}


const cubeDirs = [ {x:1,y:-1,z:0},{x:1,y:0,z:-1},{x:0,y:1,z:-1},{x:-1,y:1,z:0},{x:-1,y:0,z:1},{x:0,y:-1,z:1} ];
function offsetToCube(r,c){ const x=c; const z=r-((c-(c&1))/2); const y=-x-z; return {x,y,z}; }
function cubeToOffset(x,y,z){ const row = z + ((x-(x&1))/2); const col = x; return {row,col}; }
function neighbors(tile){ const c=offsetToCube(tile.row,tile.col); return cubeDirs.map(d=>cubeToOffset(c.x+d.x, c.y+d.y, c.z+d.z)); }

function parseLine(line){
  const parts = (''+line).trim().split(/\s+/);
  const [r,c,p, obj] = parts;
  return { row:+r, col:+c, owner: (p!=null?+p:null), obj: obj||'' };
}
function formatLine(t){ return `${t.row} ${t.col} ${t.owner}${t.obj?` ${t.obj}`:''}`; }

function getAllTiles(){ return landData.map(parseLine); }
function setTile(t){ // var olanı güncelle, yoksa ekle
  let found=false; landData = landData.map(line=>{
    const x=parseLine(line); if(x.row===t.row && x.col===t.col){ found=true; return formatLine(t);} return line; });
  if(!found) landData.push(formatLine(t));
}
function removeTile(tile){ landData = landData.filter(l=>{ const x=parseLine(l); return !(x.row===tile.row && x.col===tile.col); }); }
function findTileAt(rc){ return getAllTiles().find(t=> t.row===rc.row && t.col===rc.col ); }

// Hit-test: mevcut tile'lar içinde en yakını
function getTileAtScreen(x,y){
  const wx=(x - offsetX)/scale; const wy=(y - offsetY)/scale;
  let best=null, bestDist=1e9;
  getAllTiles().forEach(t=>{ const p=hexToPixel(t.row,t.col); const dx=wx-p.x, dy=wy-p.y; const d=Math.hypot(dx,dy); if(d<bestDist && d < tileSize*0.95){ best=t; bestDist=d; } });
  return best; // varsa döner
}

// Ghost tile için hex koordinatı hesapla
function getGhostTilePosition(screenX, screenY) {
  const wx = (screenX - offsetX) / scale;
  const wy = (screenY - offsetY) / scale;
  return pixelToHex(wx, wy);
}

// Çizim
function drawHex(cx,cy,fill,stroke='#0C666C', lw=5){
  ctx.beginPath();
  for(let i=0;i<6;i++){ const ang=Math.PI/3*i; const px=cx + tileSize*scale*Math.cos(ang); const py=cy + tileSize*scale*Math.sin(ang); (i?ctx.lineTo(px,py):ctx.moveTo(px,py)); }
  ctx.closePath(); ctx.fillStyle=fill; ctx.fill(); ctx.lineWidth=lw; ctx.strokeStyle=stroke; ctx.stroke();
}

function drawGhostHex(cx, cy, fill) {
  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  for(let i=0;i<6;i++){ 
    const ang=Math.PI/3*i; 
    const px=cx + tileSize*scale*Math.cos(ang); 
    const py=cy + tileSize*scale*Math.sin(ang); 
    (i?ctx.lineTo(px,py):ctx.moveTo(px,py)); 
  }
  ctx.closePath(); 
  ctx.fillStyle=fill; 
  ctx.fill(); 
  ctx.strokeStyle='rgba(255,255,255,0.8)'; 
  ctx.lineWidth=2; 
  ctx.setLineDash([5, 5]);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}

function ownerColor(owner){ return OWNER_COLORS[owner%OWNER_COLORS.length] || OWNER_COLORS[0]; }

let hover = null; let selected = null; let ghostTile = null; let mousePos = { x: 0, y: 0 };

function render(){
  // canvas boyutu
  canvas.width = canvas.clientWidth * devicePixelRatio; canvas.height = canvas.clientHeight * devicePixelRatio; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  ctx.fillStyle = '#0C666C'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // tüm tile'lar
  getAllTiles().forEach(t=>{
    const {x,y} = hexToPixel(t.row,t.col); const cx = x*scale + offsetX; const cy = y*scale + offsetY;
    const fill = ownerColor(Math.max(0, t.owner||0));
    const sel = selected && selected.row===t.row && selected.col===t.col;
    drawHex(cx,cy,fill, sel ? 'yellow' : '#0C666C', sel?6:5);

    // obje yaz
    if(t.obj){ ctx.fillStyle='#fff'; ctx.font=`${12*scale}px monospace`; ctx.textAlign='center'; ctx.fillText(t.obj, cx, cy+4); }
  });

  // Ghost tile (sadece add modunda ve mevcut tile olmayan yerde)
  if(mode === 'add' && ghostTile && !findTileAt(ghostTile)) {
    const {x, y} = hexToPixel(ghostTile.row, ghostTile.col);
    const cx = x * scale + offsetX;
    const cy = y * scale + offsetY;
    const fill = ownerColor(Math.max(0, +ownerInput.value || 0));
    drawGhostHex(cx, cy, fill);
    
    // Ghost obje
    const obj = objectSelect.value;
    if(obj) {
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#fff';
      ctx.font = `${12*scale}px monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(obj, cx, cy + 4);
      ctx.restore();
    }
  }

  // hover halkası
  if(hover){ const {x,y}=hexToPixel(hover.row,hover.col); const cx=x*scale+offsetX, cy=y*scale+offsetY; ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2; ctx.arc(cx,cy,tileSize*scale*0.55,0,Math.PI*2); ctx.stroke(); }
}

// Etkileşim
canvas.addEventListener('mousedown', (e)=>{ isPanning = e.button===1 || (e.button===0 && e.altKey); startX=e.clientX; startY=e.clientY; });
window.addEventListener('mouseup', ()=> isPanning=false);
window.addEventListener('mousemove', (e)=>{
  mousePos.x = e.clientX;
  mousePos.y = e.clientY;
  
  if(isPanning){ 
    offsetX += (e.clientX-startX); 
    offsetY += (e.clientY-startY); 
    startX=e.clientX; 
    startY=e.clientY; 
    render(); 
    return; 
  }
  
  const rect=canvas.getBoundingClientRect(); 
  const canvasX = e.clientX - rect.left;
  const canvasY = e.clientY - rect.top;
  
  const t=getTileAtScreen(canvasX, canvasY); 
  hover=t||null; 
  
  // Ghost tile pozisyonunu güncelle (add modunda)
  if(mode === 'add') {
    ghostTile = getGhostTilePosition(canvasX, canvasY);
  } else {
    ghostTile = null;
  }
  
  render();
});

canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); const z= e.deltaY>0? -0.1: 0.1; const newScale = Math.min(3, Math.max(0.3, scale+z));
  const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const wx=(mx-offsetX)/scale, wy=(my-offsetY)/scale; offsetX = mx - wx*newScale; offsetY = my - wy*newScale; scale=newScale; render();
},{passive:false});

canvas.addEventListener('click', (e)=>{
  const rect=canvas.getBoundingClientRect(); const t=getTileAtScreen(e.clientX-rect.left, e.clientY-rect.top);
  
  // add mode: ghost tile pozisyonunda yeni tile oluştur
  if(mode==='add'){
    if(ghostTile && !findTileAt(ghostTile)) {
      setTile({
        row: ghostTile.row,
        col: ghostTile.col, 
        owner: +ownerInput.value || 0, 
        obj: objectSelect.value || ''
      });
      selected = { row: ghostTile.row, col: ghostTile.col };
      selRow.value = ghostTile.row;
      selCol.value = ghostTile.col;
      syncIO(); 
      render(); 
      return;
    }
  }
  
  // manual mode: manuel alan kullan
  if(mode==='manual'){
    const r=parseInt(rowInput.value); const c=parseInt(colInput.value); if(Number.isFinite(r) && Number.isFinite(c)){
      const ex=findTileAt({row:r,col:c}); if(ex){ alert('Bu row/col zaten var.'); return; }
      setTile({row:r,col:c, owner: +ownerInput.value||0, obj: (objectSelect.value||'')});
      selected={row:r,col:c}; syncIO(); render(); return;
    } else if(!t){ alert('Lütfen Row/Col girin.'); return; }
  }
  
  if(!t){ selected=null; selRow.value=''; selCol.value=''; render(); return; }
  selected = { row:t.row, col:t.col }; selRow.value=t.row; selCol.value=t.col;

  if(mode==='paint'){
    setTile({ row:t.row, col:t.col, owner: +ownerInput.value||0, obj: t.obj });
  } else if(mode==='object'){
    // sol tık obje ata, sağ tık (context) kaldır
    setTile({ row:t.row, col:t.col, owner: t.owner, obj: (objectSelect.value||'') });
  } else if(mode==='erase'){
    removeTile(t);
    selected=null; selRow.value=''; selCol.value='';
  }
  syncIO(); render();
});

canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); if(mode!=='object') return; const rect=canvas.getBoundingClientRect(); const t=getTileAtScreen(e.clientX-rect.left, e.clientY-rect.top); if(!t) return; setTile({ row:t.row, col:t.col, owner:t.owner, obj:''}); syncIO(); render(); });

// Seçili tile komşularını ekle
document.getElementById('btnAddNeighbors').addEventListener('click', ()=>{
  if(!selected){ alert('Önce bir tile seç.'); return; }
  neighbors(selected).forEach(nb=>{ if(!findTileAt(nb)){ setTile({row:nb.row, col:nb.col, owner:+ownerInput.value||0, obj:''}); }});
  syncIO(); render();
});
// Delete seçili tile
document.getElementById('btnDeleteTile').addEventListener('click', ()=>{ if(!selected) return; removeTile(selected); selected=null; selRow.value=''; selCol.value=''; syncIO(); render(); });

// Manuel ekle
document.getElementById('btnAddTile').addEventListener('click', ()=>{
  const r=parseInt(rowInput.value); const c=parseInt(colInput.value); if(!Number.isFinite(r)||!Number.isFinite(c)){ alert('Geçerli row/col gir.'); return; }
  if(findTileAt({row:r,col:c})){ alert('Bu row/col zaten var.'); return; }
  setTile({row:r,col:c, owner:+ownerInput.value||0, obj:(objectSelect.value||'')}); selected={row:r,col:c}; syncIO(); render();
});

// Zoom kısayolları
function zoom(k){ const rect=canvas.getBoundingClientRect(); const mx=rect.width/2, my=rect.height/2; const newScale=Math.min(3, Math.max(0.3, scale*k)); const wx=(mx-offsetX)/scale, wy=(my-offsetY)/scale; offsetX = mx - wx*newScale; offsetY = my - wy*newScale; scale=newScale; render(); }
btnZoomIn.onclick=()=>zoom(1.1); btnZoomOut.onclick=()=>zoom(0.9); btnZoomReset.onclick=()=>{ scale=1; offsetX=offsetY=0; render(); };

// Mod geçişi
modeChips.addEventListener('click', (e)=>{ 
  const chip=e.target.closest('.chip'); 
  if(!chip) return; 
  [...modeChips.children].forEach(c=>c.classList.remove('active')); 
  chip.classList.add('active'); 
  mode=chip.dataset.mode; 
  
  // Ghost tile'ı temizle
  if(mode !== 'add') {
    ghostTile = null;
  }
  
  render();
});

// Export/Import
function exportText(){ return 'window.landData = `\n' + landData.join('\n') + '\n\n`.trim().split(\'\\n\');'; }
function syncIO(){ ioBox.value = landData.join('\n'); }

// ilk sync — eğer sayfa oyundan ayrı açılırsa var olan window.landData içeriğini alalım
syncIO();

btnExport.onclick = ()=>{ const txt=exportText(); ioBox.value = txt; ioBox.focus(); ioBox.select(); };
btnCopy.onclick = ()=>{ navigator.clipboard.writeText(ioBox.value).then(()=>{ btnCopy.textContent='Kopyalandı'; setTimeout(()=>btnCopy.textContent='Kopyala',1000); }); };
btnImport.onclick = ()=>{
  const raw = ioBox.value.trim(); if(!raw){ alert('Boş içerik.'); return; }
  let lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  // window.landData = ` ... `.trim().split('\n'); biçimini de destekle
  const startIdx = lines.findIndex(l=>l.startsWith('window.landData'));
  if(startIdx!==-1){ // çok satırlı template içinden çıkar
    const joined = lines.join('\n');
    const m = joined.match(/window\.landData\s*=\s*`([\s\S]*?)`\.trim\(\)\.split\(\'\\n\'\);/);
    if(m){ lines = m[1].split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }
  }
  landData = lines; selected=null; selRow.value=''; selCol.value=''; syncIO(); render();
};
btnClear.onclick = ()=>{ if(confirm('Tüm tile\'ları silmek istediğine emin misin?')){ landData=[]; selected=null; syncIO(); render(); } };

// Başlangıç yerleşimi görünür olsun
(function fitToContent(){
  const tiles = getAllTiles(); if(tiles.length===0){ render(); return; }
  let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
  tiles.forEach(t=>{ const {x,y}=hexToPixel(t.row,t.col); minX=Math.min(minX,x); minY=Math.min(minY,y); maxX=Math.max(maxX,x); maxY=Math.max(maxY,y); });
  const pad=80; const vw=canvas.clientWidth||800, vh=canvas.clientHeight||600;
  const contentW=(maxX-minX)+pad*2, contentH=(maxY-minY)+pad*2; const sx=vw/contentW, sy=vh/contentH; scale=Math.min(2.5, Math.max(0.4, Math.min(sx,sy)));
  offsetX = (vw - (minX+maxX)*scale)/2; offsetY = (vh - (minY+maxY)*scale)/2; render();
})();

window.addEventListener('resize', render);
</script>
</body>
</html>